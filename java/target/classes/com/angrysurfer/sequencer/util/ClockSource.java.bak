package com.angrysurfer.beatgenerator.util;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.Stack;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.sound.midi.InvalidMidiDataException;
import javax.sound.midi.MidiEvent;
import javax.sound.midi.MidiMessage;
import javax.sound.midi.MidiSystem;
import javax.sound.midi.MidiUnavailableException;
import javax.sound.midi.Receiver;
import javax.sound.midi.Sequence;
import javax.sound.midi.Sequencer;
import javax.sound.midi.ShortMessage;
import javax.sound.midi.Track;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.angrysurfer.beatgenerator.exception.MidiDeviceException;
import com.angrysurfer.beatgenerator.model.Ticker;
import com.angrysurfer.beatgenerator.service.MIDIService;
import com.angrysurfer.beatgenerator.util.listener.CyclerListener;
import com.angrysurfer.beatgenerator.util.listener.PlayerWrapper;
import com.sun.media.sound.MidiUtils;
import com.sun.media.sound.MidiUtils.TempoCache;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class ClockSource implements Runnable, Receiver {

    static Logger logger = LoggerFactory.getLogger(ClockSource.class.getCanonicalName());

    private ExecutorService executor;

    static Sequencer sequencer;

    static boolean initialized;

    static Stack<Exception> exceptions = new Stack<>();

    private final Ticker ticker;

    private Boolean stopped = false;

    private List<PlayerWrapper> playerWrappers = new ArrayList<>();

    static {
        try {
            sequencer = MidiSystem.getSequencer();
            initialized = true;
        } catch (MidiUnavailableException e) {
            logger.error(e.getMessage(), e);
            exceptions.push(e);
            initialized = false;
            throw new RuntimeException(e);
        }
    }

    /**
     *
     */

    private Set<CyclerListener> cycleListeners = new HashSet<>();

    /**
     * @param ticker
     */
    public ClockSource(Ticker ticker) {
        this.ticker = ticker;
        executor = Executors.newFixedThreadPool(ticker.getMaxTracks());
    }

    //
    public Set<CyclerListener> getCycleListeners() {
        return cycleListeners;
    }

    public void ensureDevicesOpen() throws MidiDeviceException {
        MidiDeviceException[] errors = new MidiDeviceException[1];
        ticker.getPlayers().stream().map(p -> p.getInstrument().getDevice()).filter(d -> !d.isOpen()).distinct()
                .forEach(d -> {

                    try {
                        MIDIService.select(d);
                    } catch (MidiDeviceException e) {
                        errors[0] = e;
                    }
                });

        if (Objects.nonNull(errors[0]))
            throw errors[0];
    }

    public Sequence getMasterSequence() throws InvalidMidiDataException {
        InvalidMidiDataException[] errors = new InvalidMidiDataException[1];
        Sequence sequence = new Sequence(Sequence.PPQ, ticker.getTicksPerBeat());
        Track track = sequence.createTrack();

        try {
            track.add(new MidiEvent(new ShortMessage(ShortMessage.NOTE_OFF, 0, 0, 0),
                    ticker.getTicksPerBeat() * ticker.getBeatsPerBar() * 4));
        } catch (InvalidMidiDataException e) {
            errors[0] = e;
        }

        if (Objects.nonNull(errors[0]))
            throw errors[0];

        return sequence;
    }

    public void beforeStart() throws InvalidMidiDataException, MidiUnavailableException {

        ensureDevicesOpen();

        stopped = false;

        Sequence master = getMasterSequence();

        sequencer.setSequence(master);
        sequencer.setLoopCount(ticker.getLoopCount());
        sequencer.setTempoInBPM(ticker.getTempoInBPM());
        sequencer.open();
        sequencer.getTransmitter().setReceiver(this);
        ticker.beforeStart();
    }

    public void afterEnd() {
        // sequencer.getReceivers().remove(this);
        playerWrappers.forEach(l -> {
            l.onEnd();
        });
        sequencer.close();
        ticker.afterEnd();
        stopped = false;
    }

    double getDelay() {
        return 60000 / ticker.getTempoInBPM() / ticker.getTicksPerBeat();
    }

    double getDutyCycle() {
        return 0.5;
    }

    // public Sequence generateSequence() {

    // Sequence sequence = null;

    // try {
    // beforeStart();

    // for (int i = 0; i < ticker.getTicksPerBeat() * ticker.getBeatsPerBar() * 4;
    // i++) {

    // ticker.beforeTick();
    // playerWrappers.forEach(l -> l.onTick());
    // this.executor.invokeAll(ticker.getPlayers());
    // ticker.afterTick();
    // }

    // afterEnd();
    // } catch (InvalidMidiDataException | MidiUnavailableException |
    // InterruptedException e) {
    // throw new RuntimeException(e);
    // }

    // return sequence;
    // }

    @Override
    public void run() {

        boolean started = false;

        MIDIService.reset();

        try {
            beforeStart();

            sequencer.start();
            while (sequencer.isRunning() && !stopped) {

                if (!started)
                    started = handleStarted();

                ticker.beforeTick();

                var tick = sequencer.getTickPosition();
                while (tick == sequencer.getTickPosition())
                    Thread.sleep(1);

                playerWrappers.forEach(l -> l.onTick());

                this.executor.invokeAll(ticker.getPlayers());

                Thread.sleep((long) (getDelay() * getDutyCycle()));

                ticker.afterTick();
            }

            afterEnd();
        } catch (InvalidMidiDataException | MidiUnavailableException | InterruptedException e) {
            stop();
            throw new RuntimeException(e);
        }
    }

    private boolean handleStarted() {
        // initialize the cycler too much?
        ticker.onStart();
        cycleListeners.forEach(c -> c.starting());
        return true;
    }

    public Ticker stop() {
        setStopped(true);
        if (Objects.nonNull(sequencer) && sequencer.isRunning())
            sequencer.stop();
        ticker.setPaused(false);
        ticker.getBeatCycler().reset();
        ticker.getBarCycler().reset();
        ticker.setDone(false);
        ticker.reset();
        return ticker;
    }

    public void pause() {
        if (ticker.isPaused() || isPlaying())
            ticker.setPaused(!ticker.isPaused());
    }

    public boolean isPlaying() {
        return Objects.nonNull(sequencer) ? sequencer.isRunning() : false;
    }

    public Sequencer getSequencer() {
        return sequencer;
    }

    private TempoCache tempoCache;

    @Override
    public void send(MidiMessage message, long timeStamp) {
        logger.info(com.angrysurfer.beatgenerator.model.midi.MidiMessage.lookupCommand(message.getStatus()));
        long tickPos = 0;
        if (tempoCache == null) {
            try {
                tempoCache = new TempoCache(getMasterSequence());
            } catch (InvalidMidiDataException e) {
                logger.error(e.getMessage(), e);
            }
        }
        // convert timeStamp to ticks
        if (timeStamp < 0) {
            tickPos = ticker.getTick();
        } else {
            synchronized (tempoCache) {
                try {
                    tickPos = MidiUtils.microsecond2tick(getMasterSequence(), timeStamp, tempoCache);
                } catch (InvalidMidiDataException e) {
                    logger.error(e.getMessage(), e);
                }
            }
        }
    }

    @Override
    public void close() {
        getSequencer().getReceivers().remove(this);
    }

}
package com.angrysurfer.midi.service;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import javax.sound.midi.InvalidMidiDataException;
import javax.sound.midi.MidiDevice;
import javax.sound.midi.MidiUnavailableException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import com.angrysurfer.midi.dao.TickerStatus;
import com.angrysurfer.midi.model.Ticker;
import com.angrysurfer.midi.model.midi.MidiInstrument;
import com.angrysurfer.midi.repo.RuleRepo;
import com.angrysurfer.midi.repo.StrikeRepo;
import com.angrysurfer.midi.repo.TickerRepo;
import com.angrysurfer.midi.repo.TickerStatusDAO;
import com.angrysurfer.midi.util.ClockSource;
import com.angrysurfer.midi.util.Cycler;
import com.angrysurfer.midi.util.update.TickerUpdateType;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Service
public class TickerService {

    static Logger logger = LoggerFactory.getLogger(TickerService.class.getCanonicalName());

    private Ticker ticker;
    private StrikeRepo strikeRepo;
    private RuleRepo ruleRepo;
    private TickerRepo tickerRepo;
    private SongService songService;
    private ClockSource clockSource;
    private ArrayList<ClockSource> sequenceRunners = new ArrayList<>();

    private TickerStatusDAO tickerStatusDAO;
    
    private Long lastTickId;

    public TickerService(TickerRepo tickerRepo, StrikeRepo strikeRepo,
            RuleRepo ruleRepo, SongService songService, TickerStatusDAO tickerStatusDAO) {

        this.tickerRepo = tickerRepo;
        this.ruleRepo = ruleRepo;
        this.strikeRepo = strikeRepo;
        this.songService = songService;
        this.tickerStatusDAO = tickerStatusDAO;
    }

    public void play() {

        stopRunningSequencers();
        clockSource = new ClockSource(getTicker());
        sequenceRunners.add(getClockSource());
        getClockSource().getCycleListeners().add(getSongService().getTickListener());
        getSongService().getSong().setBeatDuration(getTicker().getBeatDuration());
        getSongService().getSong().setTicksPerBeat(getTicker().getTicksPerBeat());

        this.ticker.getPlayers().forEach(p -> {
            MidiInstrument instrument = p.getInstrument();
            MidiDevice device = InstrumentService.getMidiDevice(p.getInstrument().getDeviceName());
            if (Objects.nonNull(device))
                instrument.setDevice(device);
        });

        if (Objects.nonNull(getClockSource()) && !getClockSource().isRunning())
            new Thread(getClockSource()).start();
        else {
            setClockSource(new ClockSource(getTicker()));
            new Thread(getClockSource()).start();
        }

        getTicker().getPlayers().forEach(p -> {
            try {
                MidiInstrument instrument = p.getInstrument();
                instrument.programChange(p.getPreset(), 0);
            } catch (InvalidMidiDataException | MidiUnavailableException e) {
                logger.error(e.getMessage(), e);
            }
        });

    }

    private void stopRunningSequencers() {
        sequenceRunners.forEach(sr -> sr.stop());
        sequenceRunners.clear();
    }

    public Ticker stop() {
        stopRunningSequencers();
        return getTicker();
    }

    public void pause() {
        getClockSource().pause();
    }

    public Ticker getTickerInfo() {
        return getTicker();
    }

    public TickerStatus getTickerStatus() {
        return TickerStatus.from(getTicker(), getSongService().getSong(), getClockSource().isRunning());
    }

    public List<Ticker> getAllTickerInfo() {
        return getTickerRepo().findAll();
    }

    public Ticker getTicker() {
        if (Objects.isNull(ticker)) {
            stopRunningSequencers();
            ticker = getTickerRepo().save(new Ticker());
            getTickCycler().getListeners().add(getSongService().getTickListener());
            clockSource = new ClockSource(ticker);
        }

        return ticker;
    }

    public Ticker updateTicker(Long tickerId, int updateType, long updateValue) {

        Ticker ticker = getTicker().getId().equals(tickerId) ? getTicker()
                : getTickerRepo().findById(tickerId).orElseThrow();

        switch (updateType) {
            case TickerUpdateType.PPQ:
                ticker.setTicksPerBeat((int) updateValue);
                break;

            case TickerUpdateType.BEATS_PER_BAR:
                ticker.setBeatsPerBar((int) updateValue);
                break;

            case TickerUpdateType.BPM:
                ticker.setTempoInBPM(Float.valueOf(updateValue));
                // if (Objects.nonNull(getSequenceRunner()) && ticker.getId().equals(getTicker().getId()))
                //     getSequenceRunner().getSequencer().setTempoInBPM(updateValue);
                getSongService().getSong().setTicksPerBeat(getTicker().getTicksPerBeat());
                break;

            case TickerUpdateType.PARTS:
                ticker.setParts((int) updateValue);
                getTicker().getPartCycler().reset();
                break;

            case TickerUpdateType.BASE_NOTE_OFFSET:
                ticker.setNoteOffset((double) ticker.getNoteOffset() + updateValue);
                break;

            case TickerUpdateType.BARS:
                ticker.setBars((int) updateValue);
                break;

            case TickerUpdateType.PART_LENGTH:
                ticker.setPartLength(updateValue);
                break;

            case TickerUpdateType.MAX_TRACKS:
                ticker.setMaxTracks((int) updateValue);
                break;
        }

        return getTickerRepo().save(ticker);
    }

    public synchronized Ticker next(long currentTickerId) {
        if (currentTickerId == 0 || getTicker().getPlayers().size() > 0) {
            stopRunningSequencers();
            getTickCycler().getListeners().clear();
            getBeatCycler().getListeners().clear();
            getBarCycler().getListeners().clear();
            Long maxTickerId = getTickerRepo().getMaximumTickerId();
            setTicker(Objects.nonNull(maxTickerId) && currentTickerId < maxTickerId
                    ? getTickerRepo().getNextTicker(currentTickerId)
                    : null);
            getTickCycler().getListeners().add(getSongService().getTickListener());
            getTicker().getPlayers().addAll(getStrikeRepo().findByTickerId(getTicker().getId()));
            getTicker().getPlayers().forEach(p -> p.setRules(ruleRepo.findByPlayerId(p.getId())));
            clockSource = new ClockSource(getTicker());
        }

        return getTicker();
    }

    public synchronized Ticker previous(long currentTickerId) {
        if (currentTickerId > (getTickerRepo().getMinimumTickerId())) {
            getTickCycler().getListeners().clear();
            getTickCounter().getListeners().clear();
            getBeatCycler().getListeners().clear();
            getBarCycler().getListeners().clear();
            stopRunningSequencers();
            setTicker(getTickerRepo().getPreviousTicker(currentTickerId));
            getTicker().getPlayers().addAll(getStrikeRepo().findByTickerId(getTicker().getId()));
            getTicker().getPlayers().forEach(p -> p.setRules(ruleRepo.findByPlayerId(p.getId())));
            clockSource = new ClockSource(getTicker());
            getTickCycler().getListeners().add(getSongService().getTickListener());
        }

        return getTicker();
    }

    public Ticker loadTicker(long tickerId) {
        getTickerRepo().findById(tickerId).ifPresent(this::setTicker);
        return getTicker();
    }

    public Ticker newTicker() {
        getBeatCycler().getListeners().clear();
        getBarCycler().getListeners().clear();
        getTickCycler().getListeners().clear();
        getTickCounter().getListeners().clear();
        getTicker().getBeatCounter().getListeners().clear();
        getTicker().getBarCounter().getListeners().clear();
        setTicker(null);
        return getTicker();
    }

    public Cycler getTickCounter() {
        return getTicker().getTickCounter();
    }

    public Cycler getTickCycler() {
        return getTicker().getTickCycler();
    }

    public Cycler getBeatCycler() {
        return getTicker().getBeatCycler();
    }

    public Cycler getBarCycler() {
        return getTicker().getBarCycler();
    }

    // public void clearPlayers() {
    // getTicker().getPlayers().clear();
    // }
}
